# .github/workflows/pmd-suppression-full-scan.yml
name: "Policy: PMD Suppressions (Full Repo Scan + Locations)"

on:
  workflow_dispatch:
  pull_request:
    types: [opened, synchronize, reopened, ready_for_review]
    paths:
      - "force-app/**"
      - ".github/workflows/pmd-suppression-full-scan.yml"
      - ".github/pmd-suppression-allowlist.txt"
  push:
    branches: [main, develop, release/**]
    paths:
      - "force-app/**"

jobs:
  pmd_suppression_full_scan:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      pull-requests: write
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: PMD suppression scan (full repo, with file:line output)
        id: pmdscan
        uses: actions/github-script@v7
        with:
          script: |
            const core = require('@actions/core');
            const github = require('@actions/github');
            const fs = require('fs');
            const path = require('path');
            const { execSync } = require('child_process');

            // --- Config ---
            const ALLOWLIST = '.github/pmd-suppression-allowlist.txt';
            const APEX_EXTS = new Set(['.cls', '.trigger', '.apex']);
            const IGNORE_PATH_RE = new RegExp('(^|/)(test|tests|mock|mocks)/', 'i');
            const PATTERN_RE = /@SuppressWarnings\b|NOPMD\b|NOSONAR\b|\/\/\s*PMD\b/;

            // Load allowlist
            const allowed = new Set();
            if (fs.existsSync(ALLOWLIST)) {
              for (const line of fs.readFileSync(ALLOWLIST, 'utf8').split(/\r?\n/)) {
                const trimmed = line.trim();
                if (!trimmed || trimmed.startsWith('#')) continue;
                allowed.add(trimmed.split(/\s+/)[0]);
              }
            }

            // All tracked files
            const files = execSync('git ls-files', { encoding: 'utf8' })
              .split(/\r?\n/)
              .filter(Boolean)
              .filter(f => APEX_EXTS.has(path.extname(f)));

            if (files.length === 0) {
              core.info('No Apex files found; skipping PMD suppression gate.');
              return;
            }

            core.info(`Scanning ${files.length} Apex file(s) for suppression markers...`);

            // Collect violations: [{file, line, text}]
            const violations = [];
            const perFile = new Map();  // file -> [{line, text}]

            for (const f of files) {
              if (IGNORE_PATH_RE.test(f)) continue;
              if (!fs.existsSync(f)) continue;

              let body;
              try { body = fs.readFileSync(f, 'utf8'); } catch { continue; }

              // Skip @IsTest files entirely
              if (/@IsTest\b/.test(body)) continue;

              // Respect allowlist
              if (allowed.has(f)) continue;

              const lines = body.split(/\r?\n/);
              for (let i = 0; i < lines.length; i++) {
                const lineNo = i + 1;
                const line = lines[i];
                if (PATTERN_RE.test(line)) {
                  const rec = { file: f, line: lineNo, text: line.trim() };
                  violations.push(rec);
                  if (!perFile.has(f)) perFile.set(f, []);
                  perFile.get(f).push({ line: lineNo, text: line.trim() });

                  // Create an inline error annotation in the job output
                  core.error(`PMD suppression marker`, { file: f, startLine: lineNo });
                }
              }
            }

            // If we found issues, print a grouped, detailed list and add a job summary
            if (violations.length > 0) {
              console.log('::group::PMD suppression findings (file:line → snippet)');
              for (const v of violations) {
                console.log(`${v.file}:${v.line}: ${v.text}`);
              }
              console.log('::endgroup::');

              // Add Job Summary table (visible in Checks UI)
              const rows = [];
              rows.push([{data: 'File', header: true}, {data: 'Line', header: true}, {data: 'Snippet', header: true}]);
              for (const v of violations.slice(0, 500)) {
                rows.push([v.file, String(v.line), v.text]);
              }
              await core.summary
                .addHeading('PMD Suppression Findings')
                .addTable(rows)
                .addRaw('\n')
                .write();

              // Optional: Comment on PR with details
              if (github.context.eventName === 'pull_request') {
                const bodyLines = [];
                bodyLines.push('⚠️ **PMD suppression markers found (unapproved).**');
                bodyLines.push('');
                bodyLines.push('Blocked patterns: `@SuppressWarnings`, `NOPMD`, `NOSONAR`, and `// PMD`.');
                bodyLines.push('If a rare exception is necessary, add the repo-relative file path to');
                bodyLines.push('`.github/pmd-suppression-allowlist.txt` with a JIRA reference and expiry,');
                bodyLines.push('and include justification in the PR.');
                bodyLines.push('');
                for (const [file, items] of perFile.entries()) {
                  bodyLines.push(`<details><summary><code>${file}</code> (${items.length})</summary>`);
                  bodyLines.push('');
                  bodyLines.push('```');
                  for (const it of items) {
                    bodyLines.push(`${file}:${it.line}: ${it.text}`);
                  }
                  bodyLines.push('```');
                  bodyLines.push('</details>');
                }
                await github.rest.issues.createComment({
                  ...github.context.repo,
                  issue_number: github.context.issue.number,
                  body: bodyLines.join('\n')
                });
              }

              core.setFailed(`Unapproved PMD suppressions detected in ${violations.length} location(s).`);
              return;
            }

            core.info('✅ No unapproved PMD suppressions detected.');
